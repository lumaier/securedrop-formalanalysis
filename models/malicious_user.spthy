theory SecureDrop
begin

heuristic: o "./oracles/malicious_user.py"

functions: kdf/1

builtins: symmetric-encryption, signing, diffie-hellman

/*

Color semantics:

- Yellow (#FDFD96)      Key setup/distribution
- Red (#FF6961)         Adversary activity
- Light blue (#B4D9EF)  Message Fetching
- Dark blue (#6495ED)   Messaging
- Orange (#FF7F50)      Registration/Enrollment

 */

// PQ Attacker
rule PQAttackerStart[color=#FF6961]:
  [] --[ PQAttack(), SomeCompromise() ]-> [ !PQAttacker() ]

rule PQAttacker[color=#FF6961]:
  [ !PQAttacker(), !NonPQSecKey(k) ] --> [ Out(k) ]

restriction PQAttacker:
  "All #compr #t. PQAttack() @ #compr & PrePQAttack() @ #t ==> #t < #compr"

// Channel Rules

rule ClientOut[color=#FFFFFF]:
  [ Client_Out(~sess, $Server, msg), !Message_Server($Server) ]
  -->
  [ !Client(~sess, $Server, msg) ]

rule AdversaryClientOut[color=#FF6961]:
  [ In(~sess), In(msg), !Message_Server($Server) ]
  -->
  [ !Client(~sess, $Server, msg) ]

rule ServerOut[color=#FFFFFF]:
  [ Server_Out(~sess, $Server, msg), !Message_Server($Server) ]
  -->
  [ !Server(~sess, $Server, msg) ]

rule ClientToServer[color=#FFFFFF]:
  [ !Client(~sess, $Server, msg) ]
  -->
  [ Server_In(~sess, $Server, msg) ]

rule ServerToClient[color=#FFFFFF]:
  [ !Server(~sess, $Server, msg) ]
  -->
  [ Client_In(~sess, $Server, msg) ]

rule ServerToAdversaryClient[color=#FF6961]:
  [ In(adversarySess), !Server(adversarySess, $Server, msg) ]
  --[ AdversaryActivity() ]->
  [ Out(msg) ]

// Server Rules

rule Server_Ciphertext:
  [ Server_In(~sess, $Server, <'ciphertext', c>)]
  --[ Ciphertext_IN(~sess, $Server, <'ciphertext', c>)
    , PrePQAttack() ]->
  [ !Stored_Ciphertext($Server, c)]

rule Server_Receive_Fetch_Request:
  [ Server_In(~sess, $Server, 'fetch_messages') ]
  --[ PrePQAttack() ]->
  [ Server_Fetched_Messages(~sess, $Server) ]

rule Server_Create_Challenge [derivchecks]:
  let me_pk = 'g'^~me_sk
      kmid = m_gdh^~re_sk
      pmgdh = me_pk^~re_sk
      enc_id = senc(~id, kmid)
  in
  [ Server_Fetched_Messages(~sess, $Server)
  , !Stored_Ciphertext($Server, <c, me_pk, m_gdh>)
  , Fr(~re_sk)
  , Fr(~id) ]
  --[ DHElement_Check(kmid)
    , DHElement_Check(me_pk)
    , DHElement_Check(pmgdh)
    , PrePQAttack() ]->
  [ Stored_Ciphertext_Challenge($Server, ~sess, ~id, c)
  , Server_Out(~sess, $Server, <'challenge', <enc_id, pmgdh>>)
  , !NonPQSecKey(~re_sk) ]

rule Server_Challenge_Response:
  [ Stored_Ciphertext_Challenge($Server, ~sess, ~id, c)
  , Server_In(~sess, $Server, <'solution', ~id>) ]
  --[ PrePQAttack() ]->
  [ Server_Out(~sess, $Server, <'ciphertext', c>)]

// Key Registration

rule Register_Newsroom_Key [color=#FF7F50]:
  let public_key = pk(~ltk) in
  [ Fr(~ltk) ]
  --[ OnlyOnce($A)
    , OnlyOnce($Server)
    , PrePQAttack() ]->
  [ !Ltk_Newsroom($A, ~ltk)
  , !Pk_Newsroom($A, public_key)
  , !Newsroom_Server($A, $Server)
  , !Message_Server($Server)
  , !NonPQSecKey(~ltk)
  , Out(public_key) ]

rule Reveal_Newsroom_Key [color=#FF6961]:
  [ !Ltk_Newsroom(A, ~ltk) ]
  --[ Reveal_Newsroom_Key(A)
    , SomeCompromise() ]->
  [ Out(~ltk) ]

rule Register_Source_Keys [color=#FDFD96]:
  let s_fetch_sk = kdf(<'Fetch', ~passphrase>)
      s_fetch_pk = 'g'^s_fetch_sk
  in
  [ Fr(~passphrase) ]
  --[ Register_Source(s_fetch_pk)
    , OnlyOnce($A)
    , PrePQAttack() ]->
  [ !Ltk_Source_Passphrase($A, ~passphrase)
  , Ltk_Source_Fetch_Key_Reveal($A, s_fetch_sk)
  , !NonPQSecKey(s_fetch_sk)
  , Out(s_fetch_pk) ]

rule Reveal_Source_Fetch_Key [color=#FF6961]:
  let s_fetch_pk = 'g'^s_fetch_sk
  in
  [ Ltk_Source_Fetch_Key_Reveal($A, s_fetch_sk) ]
  --[ Reveal_Source_Fetch_Key($A)
    , Reveal_Source_Fetch_Key(s_fetch_pk)
    , SomeCompromise() ]->
  [ Out(s_fetch_sk) ]

// Journalist Enrollment

rule Journalist_Enrollment [color=#FF7F50]:
  let j_fetch_pk = 'g'^~j_fetch_sk
      sig_j_pk = sign(<'signature', $J, j_fetch_pk>, ~nr_sk)
  in
  [ !Ltk_Newsroom($NR, ~nr_sk)
  , Fr(~j_fetch_sk) ]
  --[ Journalist_Verified($NR, $J)
    , OnlyOnce($J)
    , PrePQAttack() ]->
  [ Out(<j_fetch_pk, sig_j_pk>)
  , !Journalist_Enrolled($NR, $J)
  , !Ltk_Journalist_Fetch_Key($J, ~j_fetch_sk)
  , !NonPQSecKey(~j_fetch_sk) ]

rule Reveal_Journalist_Fetch_Key [color=#FF6961]:
  let j_fetch_pk = 'g'^~j_fetch_sk
  in
  [ !Ltk_Journalist_Fetch_Key($A, ~j_fetch_sk) ]
  --[ Reveal_Journalist_Fetch_Key($A)
    , Reveal_Journalist_Fetch_Key(j_fetch_pk)
    , SomeCompromise() ]->
  [ Out(~j_fetch_sk) ]

// Messaging and Fetching Protocol

rule Source_Send [derivchecks,color=#6495ED]:
  let me_pk = 'g'^~x
      m_gdh = j_fetch_pk^~x
      s_fetch_sk = kdf(<'Fetch', ~passphrase>)
      s_fetch_pk = 'g'^s_fetch_sk
      m = <~msg, $S, s_fetch_pk>
  in
  [ !Ltk_Source_Passphrase($S, ~passphrase)
  , !Pk_Newsroom($NR, nr_pk)
  , !Newsroom_Server($NR, $Server)
  , In(<j_fetch_pk, sig_j_pk>)
  , Fr(~x)
  , Fr(~msg)
  , Fr(~sess) ]
  --[ // check signatures of journalist's longterm signature and ephemeral encryption keys
      Eq(verify(sig_j_pk, <'signature', $J, j_fetch_pk>, nr_pk), true)
      // Actions for Lemmas
    , Source_Sent($S, $J, $NR, m)
    , Ciphertext_OUT(~sess, $Server, m)
    , PrePQAttack()
    ]->
  [ Client_Out(~sess, $Server, <'ciphertext', <m, me_pk, m_gdh>>)
  , !NonPQSecKey(~x) ]

rule Journalist_Fetch_Messages [color=#B4D9EF]:
  [ Fr(~sess)
  , !Journalist_Enrolled($NR, $J)
  , !Newsroom_Server($NR, $Server) ]
  --[ PrePQAttack() ]->
  [ Client_Out(~sess, $Server, 'fetch_messages')
  , !Journalist_Fetched_Messages($J, $NR, $Server, ~sess) ]

rule Journalist_Solve_Fetch_Challenge [derivchecks, color=#B4D9EF]:
  let pmgdh = ('g'^~me_sk)^~re_sk
      kmid = pmgdh^~j_fetch_sk
  in
  [ !Journalist_Fetched_Messages($J, $NR, $Server, ~sess)
  , !Ltk_Journalist_Fetch_Key($J, ~j_fetch_sk)
  , Client_In(~sess, $Server, <'challenge', <senc(~id, kmid), pmgdh>>) ]
  --[ DHElement_Check(kmid)
    , DHElement_Check(pmgdh)
    , PrePQAttack() ]->
  [ Client_Out(~sess, $Server, <'solution', ~id>) ]

rule Journalist_Recv [color=#6495ED]:
  let m = <~msg, $S, s_fetch_pk>
  in
  [ Client_In(~sess, $Server, <'ciphertext', m>)
  , !Journalist_Fetched_Messages($J, $NR, $Server, ~sess) ]
  --[ // Actions for Lemmas
      Journalist_Received($J, $NR, $S, m)
    , PrePQAttack()
    ]->
  [ Journalist_Recv($J, $NR, $S, s_fetch_pk, m) ]

rule Journalist_Send [color=#6495ED]:
  let me_pk = 'g'^~x
      m_gdh = s_fetch_pk^~x
      m = <~msg, $J>
  in
  [ Journalist_Recv($J, $NR, $S, s_fetch_pk, m_old)
  , !Newsroom_Server($NR, $Server)
  , Fr(~x)
  , Fr(~msg)
  , Fr(~sess) ]
  --[ // Actions for Lemmas
      Journalist_Response($J, s_fetch_pk, m_old, m)
    , Ciphertext_OUT(~sess, $Server, m)
    , PrePQAttack()
    ]->
  [ Client_Out(~sess, $Server, <'ciphertext', <m, me_pk, m_gdh>>)
  , !NonPQSecKey(~x) ]

rule Source_Fetch_Messages [color=#B4D9EF]:
  [ Fr(~sess)
  , !Newsroom_Server($NR, $Server) ]
  --[ PrePQAttack() ]->
  [ Client_Out(~sess, $Server, 'fetch_messages')
  , !Source_Fetched_Messages($S, $Server, ~sess) ]

rule Source_Solve_Fetch_Challenge [derivchecks, color=#B4D9EF]:
  let s_fetch_sk = kdf(<'Fetch', ~passphrase>)
      pmgdh = ('g'^~me_sk)^~re_sk
      kmid = pmgdh^s_fetch_sk
  in
  [ !Source_Fetched_Messages($S, $Server, ~sess)
  , !Ltk_Source_Passphrase($S, ~passphrase)
  , Client_In(~sess, $Server, <'challenge', <senc(~id, kmid), pmgdh>>) ]
  --[ DHElement_Check(kmid)
    , DHElement_Check(pmgdh)
    , PrePQAttack() ]->
  [ Client_Out(~sess, $Server, <'solution', ~id>) ]

rule Source_Recv [color=#6495ED, ]:
  let s_fetch_sk = kdf(<'Fetch', ~passphrase>)
      s_fetch_pk = 'g'^s_fetch_sk
      m = <~msg, $J>
  in
  [ !Source_Fetched_Messages($S, $Server, ~sess)
  , Client_In(~sess, $Server, <'ciphertext', m>)
  , !Ltk_Source_Passphrase($S, ~passphrase)
  , !Pk_Newsroom($NR, nr_pk) ]
  --[ // Actions for Lemmas
      Source_Received(s_fetch_pk, $J, m)
    , PrePQAttack()
    ]->
  []

restriction Eq:
  "All t1 t2 #x. Eq(t1, t2) @ #x ==> t1 = t2"

restriction DHElement_Check:
  "All x #t. DHElement_Check(x) @ #t ==> not(x = 'g' | x = DH_neutral)"

restriction OnlyOnce:
  "All x #i #j. OnlyOnce(x)@#i & OnlyOnce(x)@#j ==> #i = #j"

lemma Auto_Ciphertext [sources]:
"All #t1 sess server c X m_gdh.
      Ciphertext_IN(sess, server, <'ciphertext', <c, X, m_gdh>>) @ #t1
  ==>   (Ex #t2. Ciphertext_OUT(sess, server, c) @ #t2)
      | (Ex #t2.
            KU(c) @ #t2
          & #t2 < #t1)"

lemma Auto_Executability_Submission:
exists-trace
"Ex #t1 #t2 s j nr c.
        Source_Sent(s, j, nr, c) @ #t1
      & Journalist_Received(j, nr, s, c) @ #t2
      & (not Ex #x. SomeCompromise() @ #x)"

lemma Auto_Secrecy_Source_Ciphertext:
"All #t s j nr c. 
        Source_Sent(s, j, nr, c) @ #t
  ==>   (not Ex #x. K(c) @ #x)
      | (  (Ex #x. Reveal_Journalist_Fetch_Key(j) @ #x)
         | (Ex #x. Reveal_Newsroom_Key(nr) @ #x & #x < #t))"

lemma Auto_Executability_Journalist_Response:
exists-trace
"Ex #t1 #t2 s j c_old c.
        Journalist_Response(j, s, c_old, c) @ #t1
      & Source_Received(s, j, c) @ #t2
      & (not Ex #x. SomeCompromise() @ #x)"

lemma Auto_Secrecy_Journalist_Ciphertext:
"All #t1 #t2 s j c_old c.
        Journalist_Response(j, s, c_old, c) @ #t1
      & Register_Source(s) @ #t2
  ==>   (not Ex #x. K(c) @ #x)
      | (Ex #x. Reveal_Source_Fetch_Key(s) @ #x)"

end