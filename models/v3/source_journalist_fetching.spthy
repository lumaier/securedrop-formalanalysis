theory SourceJournalistMessaging
begin

builtins: symmetric-encryption, diffie-hellman, signing

rule Register_pk:
  [ Fr(~ltk) ]
  -->
  [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)), Out(pk(~ltk))]

rule Reveal_ltk:
  [ !Ltk(A, ltk) ]
  --[ Reveal(A), SomeCompromise() ]->
  [ Out(ltk) ]

rule Register_dh_pk:
  let public_component = 'g'^~ltk in
  [ Fr(~ltk) ]
  -->
  [ !Ltk_dh($A, ~ltk), !Pk_dh($A, public_component), Out(public_component)]

rule Reveal_dh_ltk:
  [ !Ltk_dh(A, ltk) ]
  --[ Reveal(A), SomeCompromise() ]->
  [ Out(ltk) ]

rule Journalist_Init:
  let je_pk = 'g'^~je_sk
      sig_je_pk = sign(je_pk, j_sk)
      sig_jc_pk = sign(jc_pk, j_sk)
  in
  [ !Ltk($J, j_sk)
  , !Pk_dh($J, jc_pk)
  , Fr(~je_sk)
  ]
  -->
  [ Out(<je_pk, sig_je_pk, jc_pk, sig_jc_pk>)
  , Journalist_Ephemeral_Key($J, ~je_sk)
  , !Journalist_Init($J, jc_pk)
  , !Journalist_Init($J, je_pk)
  ]

rule Source_Submit:
  let k = je_pk^~me_sk
      c = senc(<~m, s_pk, sc_pk>, k)
      me_pk = 'g'^~me_sk
      m_gdh = jc_pk^~me_sk 
  in
  [ !Pk($J, j_pk)
  , !Pk_dh($S, s_pk)
  , !Pk_dh($S, sc_pk)
  // this fact ensures that only a journalist could have generated the key (and the signature) 
  // -> prevents partial deconstructions
  , !Journalist_Init($J, jc_pk)
  , !Journalist_Init($J, je_pk)
  , In(<je_pk, sig_je_pk, jc_pk, sig_jc_pk>)
  , Fr(~m)
  , Fr(~me_sk) ]
  --[ Eq(verify(sig_je_pk, je_pk, j_pk), true)
    , Eq(verify(sig_jc_pk, jc_pk, j_pk), true)
    , Neq(je_pk, jc_pk)
    , Source_Submission($S, $J, ~m)
    , Symmetric_Encryption_Source_OUT(<~m, s_pk, sc_pk>, k)]->
  [ Out(<c, m_gdh, me_pk>)
  , Source_Submit($S, $J) ]

// rule Journalist_Fetch:
//   let kmid = pmgdh^jc_sk 
//       m_id = sdec(enc_m_id, kmid)
//   in
//   [ In(<pmgdh, enc_m_id>)
//   , !Ltk_dh($J, jc_sk) ]
//   --[ Symmetric_Encryption_Adversary(m_id, kmid)
//     , Neq(pmgdh, DH_neutral)
//     , Neq(pmgdh, 'g') ]->
//   [ Out(m_id)
//   , Journalist_Fetch($J, m_id) ]

rule Journalist_Recv:
  let k = me_pk^je_sk 
      msg = sdec(c, k)
      m = fst(msg)
      s_pk = fst(snd(msg))
      sc_pk = snd(snd(msg))
  in
  [ In(<c, me_pk>)
  , Journalist_Ephemeral_Key($J, je_sk)
  // , Journalist_Fetch($J, m_id) 
]
  --[ Journalist_Read($J, m)
    , Symmetric_Encryption_Source_IN(<m, s_pk, sc_pk>, k) ]->
  [ Journalist_Recv($J, m, s_pk, sc_pk) ]

rule Journalist_Reply:
  let k = s_pk^~me_sk
      je_pk = 'g'^~je_sk
      c = senc(<~m, je_pk>, k)
      me_pk = 'g'^~me_sk
      m_gdh = sc_pk^~me_sk
  in
  [ Journalist_Recv($J, m_old, s_pk, sc_pk)
  , Fr(~m)
  , Fr(~me_sk)
  , Fr(~je_sk) ]
  --[ Journalist_Response($J, m_old, ~m)
    , Symmetric_Encryption_Journalist_OUT(<~m, je_pk>, k) ]->
  [ Out(<c, m_gdh, me_pk>) ]

// rule Source_Fetch:
//   let kmid = pmgdh^sc_sk 
//       m_id = sdec(enc_m_id, kmid)
//   in
//   [ In(<pmgdh, enc_m_id>)
//   , !Ltk_dh($S, sc_sk) ]
//   --[ Symmetric_Encryption_Adversary(m_id, kmid) ]->
//   [ Out(m_id)
//   , Source_Fetch($S, m_id) ]

// rule Source_Recv:
//   let k = me_pk^s_sk
//       msg = sdec(c, k)
//       m = fst(msg)
//       je_pk = snd(msg)
//   in
//   [ In(<c, me_pk>)
//   , Source_Submit($S, $J)
//   // , Source_Fetch($S, m_id)
//   , !Ltk_dh($S, s_sk) ]
//   --[ Source_Read($S, m)
//     , Symmetric_Encryption_IN(<m, je_pk>, k) ]->
//   []

restriction Eq:
  "All t1 t2 #x. Eq(t1, t2) @ #x ==> t1 = t2"

restriction Neq:
  "All x #t. Neq(x,x) @ #t ==> F"

// prevents partial deconstruction: to encrypt something, you need to know the plaintext and the encryption key
lemma Symmetric_Encryption [sources]:
  "All msg key #t.
    Symmetric_Encryption_Source_IN(msg, key) @ #t
    ==>
    (Ex #x. Symmetric_Encryption_Source_OUT(msg, key) @ #x & #x < #t)
    | ((Ex #x. K(msg) @ #x & #x < #t) & (Ex #x. K(key) @ #x & #x < #t))"

// lemma Symmetric_Encryption_Adversary [sources]:
//   "All msg key #t.
//     Symmetric_Encryption_Adversary(msg, key) @ #t
//     ==>
//     (Ex #x. K(msg) @ #x & #x < #t) & (Ex #x. K(key) @ #x & #x < #t)"

lemma Executability_Submission:
  exists-trace
  "Ex #t1 #t2 s j m.
      Source_Submission(s, j, m) @ #t1
    & Journalist_Read(j, m) @ #t2
    & (not Ex #x. SomeCompromise() @ #x)"

// lemma Executability_Response:
//   exists-trace
//   "Ex #t1 #t2 #t3 s j m_old m.
//       Source_Submission(s, j, m_old) @ #t1
//     & Journalist_Response(j, m_old, m) @ #t2
//     & Source_Read(s, m) @ #t3
//     & (not Ex #x. SomeCompromise() @ #x)"

lemma Confidentiality_Submission:
  all-traces
  "All #t1 s j m. Source_Submission(s, j, m) @ #t1
    ==> (not Ex #x. K(m) @ #x) | (Ex #x. Reveal(s) @ #x) | (Ex #x. Reveal(j) @ #x)"

// lemma Confidentiality_Response:
//   all-traces
//   "All #t1 #t2 s j m_old m. 
//     Source_Submission(s, j, m_old) @ #t1 & Journalist_Response(j, m_old, m) @ #t2
//     ==> 
//     ((not Ex #x. K(m_old) @ #x) & (not Ex #x. K(m) @ #x)) | (Ex #x. Reveal(s) @ #x) | (Ex #x. Reveal(j) @ #x)"

end