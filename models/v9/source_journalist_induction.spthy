theory SecureDrop
begin

builtins: symmetric-encryption, diffie-hellman, signing

// KDF
functions: hkdf/1

// KEM
functions: encap/2, decap/2
equations: decap(encap(ss, pk(sk)), sk) = ss

/*

Color semantics:

- Yellow (#FDFD96)      Key setup/distribution
- Red (#FF6961)         Adversary activity
- Light blue (#B4D9EF)  Message Fetching
- Dark blue (#6495ED)   Messaging
- Orange (#FF7F50)      Registration/Enrollment

 */

// Key Registration

rule Register_Newsroom_Key [color=#FDFD96]:
  [ Fr(~ltk) ]
  -->
  [ !Ltk_Newsroom($A, ~ltk), !Pk_Newsroom($A, pk(~ltk)), Out(pk(~ltk)) ]

rule Reveal_Newsroom_Key [color=#FF6961]:
  [ !Ltk_Newsroom(A, ltk) ]
  --[ Reveal_Newsroom_Key(A), Reveal(A), SomeCompromise() ]->
  [ Out(ltk) ]

rule Register_Source_Fetching_Key [color=#FDFD96]:
  let public_component = 'g'^~ltk in
  [ Fr(~ltk) ]
  -->
  [ !Ltk_Source_Fetching($A, ~ltk), !Pk_Source_Fetching($A, public_component) ]

rule Reveal_Source_Fetching_Key [color=#FF6961]:
  [ !Ltk_Source_Fetching(A, ltk) ]
  --[ Reveal_Source_Fetching_Key(A), Reveal(A), SomeCompromise() ]->
  [ Out(ltk) ]

rule Reveal_Source_Fetching_Public_Key [color=#FF6961]:
  [ !Pk_Source_Fetching(A, public_component) ]
  --[ Reveal_Source_Fetching_Public_Key(A), Reveal(A), SomeCompromise() ]->
  [ Out(public_component) ]

rule Register_Source_Encryption_Key [color=#FDFD96]:
  [ Fr(~ltk) ]
  -->
  [ !Ltk_Source_Encryption($A, ~ltk), !Pk_Source_Encryption($A, pk(~ltk)) ]

rule Reveal_Source_Encryption_Key [color=#FF6961]:
  [ !Ltk_Source_Encryption(A, ltk) ]
  --[ Reveal_Source_Encryption_Key(A), Reveal_Source_Encryption_Key(pk(ltk)), Reveal(A), SomeCompromise() ]->
  [ Out(ltk) ]

rule Reveal_Source_Encryption_Public_Key [color=#FF6961]:
  [ !Pk_Source_Encryption(A, public_component) ]
  --[ Reveal_Source_Encryption_Public_Key(A), Reveal(A), SomeCompromise() ]->
  [ Out(public_component) ]

rule Register_Journalist_Signing_Key [color=#FDFD96]:
  [ Fr(~ltk) ]
  -->
  [ !Ltk_Journalist_Signing($A, ~ltk), !Pk_Journalist_Signing($A, pk(~ltk)), Out(pk(~ltk)) ]

rule Reveal_Journalist_Signing_Key [color=#FF6961]:
  [ !Ltk_Journalist_Signing(A, ltk) ]
  --[ Reveal_Journalist_Signing_Key(A), Reveal(A), SomeCompromise() ]->
  [ Out(ltk) ]

rule Register_Journalist_Fetching_Key [color=#FDFD96]:
  let public_component = 'g'^~ltk in
  [ Fr(~ltk) ]
  -->
  [ !Ltk_Journalist_Fetching($A, ~ltk), !Pk_Journalist_Fetching($A, public_component), Out(public_component) ]

rule Reveal_Journalist_Fetching_Key [color=#FF6961]:
  [ !Ltk_Journalist_Fetching(A, ltk) ]
  --[ Reveal_Journalist_Fetching_Key(A), Reveal(A), SomeCompromise() ]->
  [ Out(ltk) ]

// Journalist Enrollment

rule Journalist_Init [color=#FF7F50]:
  let sig_jc_pk = sign(<'fetch', jc_pk>, j_sk)
  in
  [ !Ltk_Journalist_Signing($J, j_sk)
  , !Pk_Journalist_Fetching($J, jc_pk)
  ]
  -->
  [ Out(<jc_pk, sig_jc_pk>) ]

rule Journalist_Register_Ephemeral_Key [color=#FF7F50]:
  let je_pk = pk(~je_sk)
      sig_je_pk = sign(<'ephemeral', je_pk>, j_sk)
  in
  [ !Ltk_Journalist_Signing($J, j_sk)
  , Fr(~je_sk) ]
  -->
  [ Out(<je_pk, sig_je_pk>)
  , Journalist_Ephemeral_Key($J, ~je_sk)
  , Journalist_Ephemeral_Key_Reveal($J, ~je_sk) ]

rule Reveal_Journalist_Ephemeral_Key [color=#FF6961]:
  [ Journalist_Ephemeral_Key_Reveal(J, je_sk) ]
  --[ Reveal_Journalist_Ephemeral_Key(J, pk(je_sk)), Reveal(J), SomeCompromise() ]->
  [ Out(je_sk) ]


rule Journalist_Enrollment [color=#FF7F50]:
  let sig_j_pk = sign(j_pk, nr_sk)
  in
  [ !Ltk_Newsroom($NR, nr_sk)
  , !Pk_Journalist_Signing($J, j_pk) ]
  --[ Journalist_Verified($NR, $J) ]->
  [ Out(<j_pk, sig_j_pk>)
  , !Journalist_Enrolled($NR, $J) ]

// Messaging and Fetching Protocol

rule Source_Submit [derivchecks, color=#6495ED]:
  let s_pk = pk(s_sk)
      sc_pk = 'g'^sc_sk
      jc_pk = 'g'^jc_sk
      k = hkdf(~ss)
      m = <'msg', ~msg, s_pk, sc_pk, sign(<'journalist', $J>, s_sk)>
      c = senc(m, k)
      ss_encap = encap(~ss, je_pk)
      me_pk = 'g'^~me_sk
      m_gdh = jc_pk^~me_sk 
  in
  [ !Ltk_Source_Encryption($S, s_sk)
  , !Ltk_Source_Fetching($S, sc_sk)
  , !Pk_Newsroom($NR, nr_pk)
  , !Pk_Journalist_Signing($J, j_pk)
  , In(<j_pk, sig_j_pk, je_pk, sig_je_pk, jc_pk, sig_jc_pk>)
  , Fr(~msg)
  , Fr(~ss)
  , Fr(~me_sk) ]
  --[ Eq(verify(sig_j_pk, j_pk, nr_pk), true)
    , Eq(verify(sig_je_pk, <'ephemeral', je_pk>, j_pk), true)
    , Eq(verify(sig_jc_pk, <'fetch', jc_pk>, j_pk), true)
    , Symmetric_Encryption_OUT(m, k)
    , Source_Submission($S, $J, $NR, ~msg)
    , Source_Message_Sent($S, $J, je_pk, $NR, ~msg)
    , Running($S, $J, k) ]->
  [ Out(<c, m_gdh, me_pk, ss_encap>) ]

rule Journalist_Fetch [color=#B4D9EF]:
  let kmid = pmgdh^jc_sk
      m = <flag, m_id>
  in
  [ In(<pmgdh, senc(m, kmid)>)
  , !Ltk_Journalist_Fetching($J, jc_sk) ]
  // this action ensures that the adversary needs to know m_id and kmid to generate enc_m_id
  // -> prevents partial deconstructions
  --[ Symmetric_Encryption_IN(m, kmid)
    , Eq(flag, 'm_id') // with this term we enforce Tamarin to "use" the decryted message. If terms are not used, Tamarin doesn't model whether decryption failed or not.
  ]->
  [ Out(m_id)
  , Journalist_Fetch($J, m_id) ]

rule Journalist_Recv [derivchecks, color=#6495ED]:
  let ss = decap(ss_encap, je_sk)
      k = hkdf(ss)
      sc_pk = 'g'^sc_sk
      m = <flag, msg, s_pk, sc_pk, sig_J>
  in
  [ In(<senc(m, k), ss_encap>)
  , Journalist_Ephemeral_Key($J, je_sk)
  , Journalist_Fetch($J, m_id) 
  , !Pk_Source_Encryption($S, s_pk) ]
  --[ Journalist_Read($J, msg)
    , Symmetric_Encryption_IN(m, k)
    , Commit($J, $S, k)
    , Eq(flag, 'msg')
    , Eq(verify(sig_J, <'journalist', $J>, s_pk), true)]->
  [ Journalist_Recv($J, msg, s_pk, sc_pk) ]

rule Journalist_Reply [color=#6495ED]:
  let k = hkdf(~ss)
      m = <'msg', ~msg, $J>
      c = senc(m, k)
      ss_encap = encap(~ss, s_pk)
      me_pk = 'g'^~me_sk
      m_gdh = sc_pk^~me_sk
  in
  [ Journalist_Recv($J, msg_old, s_pk, sc_pk)
  , !Ltk_Journalist_Signing($J, j_sk)
  , Fr(~msg)
  , Fr(~me_sk)
  , Fr(~je_sk)
  , Fr(~ss) ]
  --[ Journalist_Response($J, msg_old, ~msg)
    , Journalist_Message_Sent($J, s_pk, ~msg)
    , Symmetric_Encryption_OUT(m, k)
    , Journalist_Fetch_OUT(m_gdh, ~me_sk) ]->
  [ Out(<c, m_gdh, me_pk, ss_encap>) ]

rule Source_Fetch [color=#B4D9EF]:
  let kmid = pmgdh^sc_sk
      m = <flag, m_id>
  in
  [ In(<pmgdh, senc(m, kmid)>)
  , !Ltk_Source_Fetching($S, sc_sk) ]
  --[ Symmetric_Encryption_IN(m, kmid)
    , Eq(flag, 'm_id') // with this term we enforce Tamarin to "use" the decryted message. If terms are not used, Tamarin doesn't model whether decryption failed or not.
    , Source_Fetch_IN(kmid, pmgdh, sc_sk) ]->
  [ Out(m_id)
  , Source_Fetch($S, m_id) ]

rule Source_Recv [color=#6495ED]:
  let ss = decap(ss_encap, s_sk)
      k = hkdf(ss)
      m = <flag, msg, $J>
  in
  [ In(<senc(m, k), ss_encap>)
  , Source_Fetch($S, m_id)
  , !Ltk_Source_Encryption($S, s_sk) ]
  --[ Source_Read($S, msg)
    , Symmetric_Encryption_IN(m, k)
    , Eq(flag, 'msg') ]->
  [ Source_Recv($S, msg, $J) ]

rule Source_Reply [derivchecks, color=#6495ED]:
  let s_pk = pk(s_sk)
      sc_pk = 'g'^sc_sk
      jc_pk = 'g'^jc_sk
      k = hkdf(~ss)
      m = <'msg', ~msg, s_pk, sc_pk, sign(<'journalist', $J>, s_sk)>
      c = senc(m, k)
      ss_encap = encap(~ss, je_pk)
      me_pk = 'g'^~me_sk
      m_gdh = jc_pk^~me_sk 
  in
  [ Source_Recv($S, msg_old, $J)
  , !Ltk_Source_Encryption($S, s_sk)
  , !Ltk_Source_Fetching($S, sc_sk)
  , !Pk_Newsroom($NR, nr_pk)
  , !Pk_Journalist_Signing($J, j_pk)
  , In(<j_pk, sig_j_pk, je_pk, sig_je_pk, jc_pk, sig_jc_pk>)
  , Fr(~msg)
  , Fr(~ss)
  , Fr(~me_sk) ]
  --[ Eq(verify(sig_j_pk, j_pk, nr_pk), true)
    , Eq(verify(sig_je_pk, <'ephemeral', je_pk>, j_pk), true)
    , Eq(verify(sig_jc_pk, <'fetch', jc_pk>, j_pk), true)
    , Symmetric_Encryption_OUT(m, k)
    , Source_Message_Sent($S, $J, je_pk, $NR, ~msg)
    , Source_Response($S, $J, $NR, msg_old, ~msg)
    , Running($S, $J, k) ]->
  [ Out(<c, m_gdh, me_pk, ss_encap>) ]

restriction Eq:
  "All t1 t2 #x. Eq(t1, t2) @ #x ==> t1 = t2"

// restriction Neq:
//   "All x #t. Neq(x,x) @ #t ==> F"

/* Without this Source-Lemma, Tamarin thinks that the "Fetch" Rules act as decryption oracles.
   This Source-Lemma ensures that if a party gets a ciphertext, either the adversary encrypted the message (i.e, it knew the message)
   or the adversary got the ciphertext from an output in the protocol.
*/
lemma Symmetric_Encryption [sources]:
"All m key #t.
        Symmetric_Encryption_IN(m, key) @ #t
  ==>   ( (Ex #x. KU(m) @ #x & #x < #t)
        & (Ex #x. KU(key) @ #x & #x < #t))
      | (Ex #x. Symmetric_Encryption_OUT(m, key) @ #x & #x < #t)"

// lemma Verified_Journalist [reuse]:
// "All #t1 #t2 s nr j m. 
//         Source_Submission(s, j, nr, m) @ #t1
//       & Journalist_Read(j, m) @ #t2
//   ==>   (Ex #x. Journalist_Verified(nr, j) @ #x)
//       | (Ex #x. SomeCompromise() @ #x)"

lemma Executability_Submission:
exists-trace
"Ex #t1 #t2 s j nr m.
        Source_Submission(s, j, nr, m) @ #t1
      & Journalist_Read(j, m) @ #t2
      & (not Ex #x. SomeCompromise() @ #x)"

lemma Executability_Journalist_Response:
exists-trace
"Ex #t1 #t2 #t3 #t4 s j nr m_old m.
        Source_Submission(s, j, nr, m_old) @ #t1
      & Journalist_Read(j, m_old) @ #t2
      & Journalist_Response(j, m_old, m) @ #t3
      & Source_Read(s, m) @ #t4
      & (not Ex #x. SomeCompromise() @ #x)"

lemma Executability_Source_Response:
exists-trace
"Ex #t1 #t2 #t3 #t4 #t5 #t6 s j nr m_old m m_new.
        Source_Submission(s, j, nr, m_old) @ #t1
      & Journalist_Read(j, m_old) @ #t2
      & Journalist_Response(j, m_old, m) @ #t3
      & Source_Read(s, m) @ #t4
      & Source_Response(s, j, nr, m, m_new) @ #t5
      & Journalist_Read(j, m_new) @ #t6
      & (not Ex #x. SomeCompromise() @ #x)"

lemma Confidentiality_Source_Message:
"All #t s j je_pk nr m. 
        Source_Message_Sent(s, j, je_pk, nr, m) @ #t
  ==>   (not Ex #x. K(m) @ #x)
      | (Ex #x. Reveal_Journalist_Signing_Key(j) @ #x)
      | (Ex #x. Reveal_Journalist_Ephemeral_Key(j, je_pk) @ #x)
      | (Ex #x. Reveal_Newsroom_Key(nr) @ #x)"

lemma Confidentiality_Journalist_Message:
"All #t j s m. 
        Journalist_Message_Sent(j, s, m) @ #t
  ==>   (not Ex #x. K(m) @ #x)
      | (Ex #x. Reveal_Source_Encryption_Key(s) @ #x)"

lemma Non_Injective_Key_Agreement:
"All #t a b k. 
        Commit(b, a, k) @ #t
  ==>   (Ex #x. Running(a, b, k) @ #x) 
      | (Ex #x. Reveal(a) @ #x)
      | (Ex #x. Reveal(b) @ #x)"
  
lemma Injective_Key_Agreement:
"All #t a b k. 
        Commit(b, a, k) @ #t
  ==>   (Ex #x. Running(a, b, k) @ #x 
              & #x < #t
              & not (Ex a2 b2 #t2. Commit(b2, a2, k) @ #t2 & not (#t2 = #t)))
      | (Ex #x. Reveal(a) @ #x)
      | (Ex #x. Reveal(b) @ #x)"

end