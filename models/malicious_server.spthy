theory SecureDrop
begin

/*
Color semantics:

- Yellow (#FDFD96)      Key setup/distribution
- Red (#FF6961)         Adversary activity
- Light blue (#B4D9EF)  Message Fetching
- Dark blue (#6495ED)   Messaging
- Orange (#FF7F50)      Registration/Enrollment
*/

builtins: symmetric-encryption, diffie-hellman, signing

heuristic: o "./oracles/oracle.py"

functions: kdf/1, pqpk/1, bot/0, APKE_Enc/3, APKE_Dec/2, APKE_Vfy/2, PKE_Enc/2, PKE_Dec/2
equations: APKE_Dec(APKE_Enc(skS, pqpk(skR), m), skR) = m,
  APKE_Vfy(APKE_Enc(skS, pkrR, m), pk(skS)) = true,
  PKE_Dec(PKE_Enc(pk(skR), m), skR) = m

#include "parts/channel.spthy"

// PQ Attacker
rule PQAttackerStart[color=#FF6961]:
  [] --[ PQAttack(), AdversaryActivity() ]-> [ !PQAttacker() ]

rule PQAttacker[color=#FF6961]:
  [ !PQAttacker(), !NonPQSecKey(k) ] --> [ Out(k) ]

restriction PQAttacker:
  "All #compr #t. PQAttack() @ #compr & PrePQAttack() @ #t ==> #t < #compr"

// Key Registration
rule Register_Newsroom_Key [color=#FF7F50]:
  let public_key = pk(~ltk) in
  [ Fr(~ltk) ]
  --[ PrePQAttack()
    , OnlyOnce($NR) ]->
  [ !SecureDropInstance($NR)
  , !Ltk_Newsroom($NR, ~ltk)
  , !Pk_Newsroom($NR, public_key)
  , Out(public_key)
  , !NonPQSecKey(~ltk) ]

rule Reveal_Newsroom_Key [color=#FF6961]:
  [ !Ltk_Newsroom($NR, ~ltk) ]
  --[ Reveal_Newsroom_Key($NR)
    , AdversaryActivity() ]->
  [ Out(~ltk) ]

rule Register_Source_Passphrase [color=#FF7F50]:
  let s_fetching_pk = 'g'^~s_fetching_sk
      s_pke_pk = pk(~s_pke_sk)
      s_apke_pk = pqpk(~s_apke_sk)
  in
  [ Fr(~s_fetching_sk), Fr(~s_pke_sk), Fr(~s_apke_sk) ]
  --[ PrePQAttack() ]->
  [ !Ltk_Source($A, ~s_fetching_sk, ~s_pke_sk, ~s_apke_sk)
  , !NonPQSecKey(~s_fetching_sk)
  , !NonPQSecKey(~s_pke_sk)
  , Out(<s_fetching_pk, s_pke_pk, s_apke_pk>) ]

rule Reveal_Source_Fetching [color=#FF6961]:
  let s_dh_pk = 'g'^s_dh_sk
  in
  [ !Ltk_Source($A, ~s_fetching_sk, ~s_pke_sk, ~s_apke_sk) ]
  --[ Reveal_Source_Fetching($A)
    , Reveal_Source_Fetching('g'^~s_fetching_sk)
    , AdversaryActivity() ]->
  [ Out(~s_fetching_sk) ]

rule Reveal_Source_PKE [color=#FF6961]:
  let s_pke_pk = pk(~s_pke_sk)
  in
  [ !Ltk_Source($A, ~s_fetching_sk, ~s_pke_sk, ~s_apke_sk) ]
  --[ Reveal_Source_PKE($A)
    , Reveal_Source_PKE(s_pke_pk)
    , AdversaryActivity() ]->
  [ Out(~s_pke_sk) ]

rule Reveal_Source_APKE [color=#FF6961]:
  let s_apke_pk = pqpk(~s_apke_sk)
  in
  [ !Ltk_Source($A, ~s_fetching_sk, ~s_pke_sk, ~s_apke_sk) ]
  --[ Reveal_Source_KEM($A)
    , Reveal_Source_KEM(s_apke_pk)
    , AdversaryActivity() ]->
  [ Out(~s_apke_sk) ]

// Journalist Enrollment

rule Journalist_Enrollment [color=#FF7F50]:
  let j_sig_pk = pk(~j_sig_sk)
      j_fetching_pk = 'g'^~j_fetching_sk
      j_apke_pk = pqpk(~j_apke_sk)
      sig_j_pk = sign(<'long-term', j_sig_pk, j_fetching_pk, j_apke_pk>, ~nr_sk)
  in
  [ !Ltk_Newsroom($NR, ~nr_sk)
  , Fr(~j_sig_sk)
  , Fr(~j_fetching_sk)
  , Fr(~j_apke_sk) ]
  --[ Journalist_Verified($NR, $J)
    , OnlyOnce($J)
    , PrePQAttack() ]->
  [ Out(<j_sig_pk, j_fetching_pk, j_apke_pk, sig_j_pk>)
  , !Journalist_Enrolled($NR, $J)
  , !Ltk_Journalist_SIG_Key($J, ~j_sig_sk)
  , !Ltk_Journalist_FETCHING_Key($J, ~j_fetching_sk)
  , !Ltk_Journalist_APKE_Key($J, ~j_apke_sk)
  , !NonPQSecKey(~j_sig_sk)
  , !NonPQSecKey(~j_fetching_sk) ]

rule Reveal_Journalist_SIG_Key [color=#FF6961]:
  let j_sig_pk = pk(~j_sig_sk)
  in
  [ !Ltk_Journalist_SIG_Key($A, ~j_sig_sk) ]
  --[ Reveal_Journalist_SIG($A)
    , Reveal_Journalist_SIG(j_sig_pk)
    , AdversaryActivity() ]->
  [ Out(~j_sig_sk) ]

rule Reveal_Journalist_Fetching [color=#FF6961]:
  let j_dh_pk = 'g'^~j_fetching_sk
  in
  [ !Ltk_Journalist_FETCHING_Key($A, ~j_fetching_sk) ]
  --[ Reveal_Journalist_Fetching($A)
    , Reveal_Journalist_Fetching(j_dh_pk)
    , AdversaryActivity() ]->
  [ Out(~j_fetching_sk) ]

rule Reveal_Journalist_APKE [color=#FF6961]:
  let j_apke_pk = pqpk(~j_apke_sk)
  in
  [ !Ltk_Journalist_APKE_Key($A, ~j_apke_sk) ]
  --[ Reveal_Journalist_APKE($A)
    , Reveal_Journalist_APKE(j_apke_pk)
    , AdversaryActivity() ]->
  [ Out(~j_apke_sk) ]

rule Journalist_Register_Ephemeral_Key [color=#FF7F50]:
  let j_epke_pk = pk(~j_epke_sk)
      j_eapke_pk = pqpk(~j_eapke_sk)
      sig_je_pk = sign(<'ephemeral', j_epke_pk, j_eapke_pk>, ~j_sig_sk)
  in
  [ !Ltk_Journalist_SIG_Key($J, ~j_sig_sk)
  , Fr(~j_epke_sk)
  , Fr(~j_eapke_sk) ]
  --[ PrePQAttack() ]->
  [ Out(<j_epke_pk, j_eapke_pk, sig_je_pk>)
  , Journalist_Ephemeral_Key($J, ~j_epke_sk, ~j_eapke_sk)
  , !Journalist_Ephemeral_Key_Reveal($J, ~j_epke_sk, ~j_eapke_sk)
  , !NonPQSecKey(~j_epke_sk) ]

rule Reveal_Journalist_EPKE [color=#FF6961]:
  let j_epke_pk = pk(~j_epke_sk)
  in
  [ !Journalist_Ephemeral_Key_Reveal($J, ~j_epke_sk, ~j_eapke_sk) ]
  --[ Reveal_Journalist_EPKE($A)
    , Reveal_Journalist_EPKE(j_epke_pk)
    , AdversaryActivity() ]->
  [ Out(~j_epke_sk) ]

rule Reveal_Journalist_EAPKE [color=#FF6961]:
  let j_apke_pk = pqpk(~j_eapke_sk)
  in
  [ !Journalist_Ephemeral_Key_Reveal($J, ~j_epke_sk, ~j_eapke_sk) ]
  --[ Reveal_Journalist_APKE($A)
    , Reveal_Journalist_APKE(j_apke_pk)
    , AdversaryActivity() ]->
  [ Out(~j_eapke_sk) ]

// SOURCE MODEL
// Sending
rule Source_Send [color=#6495ED]:
  let s_apke_pk = pqpk(~s_apke_sk)
      pt1 = <'submission', ~msg>
      ct1 = APKE_Enc(~s_apke_sk, j_eapke_pk, pt1)
      pt2 = <'pk', 'g'^~s_fetching_sk, pk(~s_pke_sk), s_apke_pk>
      ct2 = PKE_Enc(j_epke_pk, pt2)
      j_fetching_pk = 'g'^k
      ct3 = j_fetching_pk^~x
      ct4 = 'g'^~x
  in
  [ !Ltk_Source($S, ~s_fetching_sk, ~s_pke_sk, ~s_apke_sk)
  , !Pk_Newsroom($NR, nr_pk)
  , In(<j_sig_pk, j_fetching_pk, j_apke_pk, sig_j_pk, j_epke_pk, j_eapke_pk, sig_je_pk>)
  , Fr(~sess), Fr(~x), Fr(~msg), Fr(~id) ]
  --[ // check signatures of journalist's longterm signature and ephemeral encryption keys
      Eq(verify(sig_j_pk, <'long-term', j_sig_pk, j_fetching_pk, j_apke_pk>, nr_pk), true)
    , Eq(verify(sig_je_pk, <'ephemeral', j_epke_pk, j_eapke_pk>, j_sig_pk), true)
      // Actions for Lemmas
    , Source_Sent(s_apke_pk, j_eapke_pk, $NR, ~msg)
    , SubmissionSource(<ct1, ct2, ct3, ct4>)
    , ServerSource(<ct1, ct2>)
    , PrePQAttack()
    ]->
  [ !Submission($NR, ~id, <ct1, ct2, ct3, ct4>)
  , FetchToken(~id)
  , !NonPQSecKey(~x) ]

// Receiving
rule Source_Query [color=#6495ED]:
  [ !Ltk_Source($S, ~s_fetching_sk, ~s_pke_sk, ~s_apke_sk)
  , !Pk_Newsroom($NR, nr_pk)
  , Fr(~sess) ]
  --[ ClientSource('request')
    , PrePQAttack() ]->
  [ Client_Out(~sess, $NR, 'request')
  , SourceQueried($S, $NR, ~sess, ~s_fetching_sk) ]

rule Source_ChallengeResponse [color=#6495ED]:
  let challenge_key = 'g'^k
  in
  [ SourceQueried($S, $NR, ~sess, ~s_fetching_sk)
  , Client_In(~sess, $NR, <challenge_key, senc(id, challenge_key^~s_fetching_sk)>) ]
  --[ PrePQAttack() ]->
  [ Client_Out(~sess, $NR, id)
  , SourceResponded($S, $NR, ~sess) ]

rule Source_Recv [color=#6495ED]:
  let pt1 = <'submission', m>
      ct1 = APKE_Enc(skR, pk(~s_apke_sk), pt1)
  in
  [ SourceResponded($S, $NR, ~sess)
  , Client_In(~sess, $NR, <ct1, ct2>)
  , In(<j_sig_pk, j_fetching_pk, j_apke_pk, sig_j_pk>)
  , !Ltk_Source($S, ~s_fetching_sk, ~s_pke_sk, ~s_apke_sk)
  , !Pk_Newsroom($NR, nr_pk) ]
  --[ Eq(APKE_Vfy(ct1, j_apke_pk), true)
    , Eq(verify(sig_j_pk, <'long-term', j_sig_pk, j_fetching_pk, j_apke_pk>, nr_pk), true)
      // Actions for Lemmas
    , Source_Received(pqpk(~s_apke_sk), j_apke_pk, $NR, m)
    , PrePQAttack()
    ]->
  []

// JOURNALISTS
// Receiving
rule Journalist_Query [color=#6495ED]:
  [ !Journalist_Enrolled($NR, $J)
  , Fr(~sess) ]
  --[ ClientSource('request')
    , PrePQAttack() ]->
  [ Client_Out(~sess, $NR, 'request')
  , JournalistQueried($J, $NR, ~sess) ]

rule Journalist_ChallengeResponse [color=#6495ED]:
  [ JournalistQueried($J, $NR, ~sess)
  , !Ltk_Journalist_FETCHING_Key($J, ~j_fetching_sk)
  , Client_In(~sess, $NR, <challenge_key, senc(id, challenge_key^~j_fetching_sk)>) ]
  --[ PrePQAttack() ]->
  [ Client_Out(~sess, $NR, id)
  , JournalistResponded($J, $NR, ~sess) ]

rule Journalist_Recv [color=#6495ED,derivchecks]:
  let pt1 = <'submission', m>
      ct1 = APKE_Enc(skR, pk(~j_eapke_sk), pt1)
      s_fetching_pk = 'g'^k
      pt2 = <'pk', s_fetching_pk, s_pke_pk, s_apke_pk>
  in
  [ JournalistResponded($J, $NR, ~sess)
  , Journalist_Ephemeral_Key($J, ~j_epke_sk, ~j_eapke_sk)
  , Client_In(~sess, $NR, <ct1, PKE_Enc(pk(~j_pke_sk), pt2)>) ]
  --[ Eq(APKE_Vfy(ct1, s_apke_pk), true)
      // Actions for Lemmas
    , Journalist_Received(pqpk(~j_eapke_sk), $NR, s_apke_pk, m)
    , PrePQAttack()
    ]->
  [ Journalist_Recv($J, s_fetching_pk, s_pke_pk, s_apke_pk) ]

// Sending
rule Journalist_Send [color=#6495ED]:
  let j_apke_pk = pqpk(~j_apke_sk)
      pt = <'submission', ~msg>
      ct1 = APKE_Enc(~j_apke_sk, s_apke_pk, pt)
      ct3 = s_fetching_pk^~x
      ct4 = 'g'^~x
  in
  [ Journalist_Recv($J, s_fetching_pk, s_pke_pk, s_apke_pk)
  , !Journalist_Enrolled($NR, $J)
  , !Ltk_Journalist_APKE_Key($J, ~j_apke_sk)
  , Fr(~sess), Fr(~msg), Fr(~x), Fr(~id) ]
  --[ SubmissionSource(<ct1, '0x0', ct3, ct4>)
    , ServerSource(<ct1, '0x0'>)
      // Actions for Lemmas
    , Journalist_Sent($J, $NR, s_apke_pk, ~msg)
    , PrePQAttack()
    ]->
  [ !Submission($NR, ~id, <ct1, '0x0', ct3, ct4>)
  , FetchToken(~id)
  , !NonPQSecKey(~x) ]

// SECUREDROP INSTANCE

rule ServerChallenge:
  let pk = 'g'^k1
      ss = 'g'^k2
  in
  [ Server_In(~sess, $NR, 'request')
  , !Submission($NR, ~id, <ct1, ct2, ss, pk>)
  , Fr(~r), Fr(~chall) ]
  --[ ServerSource(<pk^~r, senc(~chall, ss^~r)>)
    , ClientSource(~chall)
    , PrePQAttack() ]->
  [ Server_Out(~sess, $NR, <pk^~r, senc(~chall, ss^~r)>)
  , Challenged($NR, ~sess, ~id, ~chall, ct1, ct2) ]

rule ServerChallengeSuccess:
  [ Challenged($NR, ~sess, ~id, ~chall, ct1, ct2)
  , FetchToken(~id)
  , Server_In(~sess, $NR, ~chall) ]
  --[ Fetched(~id)
    , PrePQAttack() ]->
  [ Server_Out(~sess, $NR, <ct1, ct2>) ]

rule AdversarySubmit:
  [ In(cts), Fr(~id) ]
  --[ Submitted(cts)
    , AdversaryActivity() ]->
  [ !Submission($NR, ~id, cts)
  , FetchToken(~id) ]

rule SubmissionAccess:
  [ !PassiveCompromise($NR), !Submission($NR, ~id, cts) ]
  --[ SubmissionSources(cts)
    , DBRead(~id)
    , AdversaryActivity() ]->
  [ Out(cts) ]

restriction SubmissionAccessTime:
  "All id #t1 #t2. DBRead(id) @ #t1 & Fetched(id) @ #t2 ==> #t1 < #t2"

// RESTRICTIONS AND LEMMAS

lemma Submissions[sources]:
  "All cts #t. SubmissionSources(cts) @ #t
    ==>   (Ex #x. SubmissionSource(cts) @ #x)
        | (Ex #x. KU(cts) @ #x & #x < #t)"

lemma SecureChannelClientSources[sources]:
  "All m #t. ClientSources(m) @ #t
    ==>   (Ex #x. ClientSource(m) @ #x)
        | (Ex #x. KU(m) @ #x & #x < #t)"

lemma SecureChannelServerSources[sources]:
  "All m #t. ServerSources(m) @ #t
    ==>   (Ex #x. ServerSource(m) @ #x)
        | (Ex ct1 ct2 #x1 #x2. m = <ct1, ct2>
            & KU(ct1) @ #x1 & #x1 < #t
            & KU(ct2) @ #x2 & #x2 < #t)
        | (Ex #x. KU(m) @ #x & #x < #t)"

restriction Eq:
  "All t1 t2 #x. Eq(t1, t2) @ #x ==> t1 = t2"

// restriction DHElement_Check:
//   "All x #t. DHElement_Check(x) @ #t ==> not(x = 'g' | x = DH_neutral)"

restriction OnlyOnce:
  "All x #i #j. OnlyOnce(x)@#i & OnlyOnce(x)@#j ==> #i = #j"

// not automatically verifiable
// lemma Auto_Executability_Submission:
// exists-trace
// "Ex #t1 #t2 s_dh_pk j_sig_pk j_edh_pk j_ekem_pk nr m.
//         Source_Sent(s_dh_pk, j_sig_pk, j_edh_pk, j_ekem_pk, nr, m) @ #t1
//       & Journalist_Received(j_sig_pk, j_edh_pk, nr, s_dh_pk, m) @ #t2
//       & (not Ex #x. AdversaryActivity() @ #x)"

// lemma Auto_Secrecy_Source_Message:
// "All #t s_dh_pk j_sig_pk j_edh_pk j_ekem_pk nr m.
//         Source_Sent(s_dh_pk, j_sig_pk, j_edh_pk, j_ekem_pk, nr, m) @ #t
//   ==>   (not Ex #x. K(m) @ #x)
//       | (Ex #x. Reveal_Journalist_SIG_Key(j_sig_pk) @ #x & #x < #t)
//       | (Ex #x. Reveal_Newsroom_Key(nr) @ #x & #x < #t)
//       | (  (  (Ex #x. Reveal_Journalist_EDH_Key(j_edh_pk) @ #x)
//             | (Ex #x. PQAttack() @ #x))
//          & (Ex #x. Reveal_Journalist_EKEM_Key(j_ekem_pk) @ #x))"

// lemma Auto_Injective_Agreement_Source_Message:
// "All #t1 #t2 j_sig_pk j_edh_pk nr s_dh_pk m.
//         Journalist_Received(j_sig_pk, j_edh_pk, nr, s_dh_pk, m) @ #t1
//       & Register_Source(s_dh_pk) @ #t2
//   ==>   (Ex j_ekem_pk #x1.
//                 Source_Sent(s_dh_pk, j_sig_pk, j_edh_pk, j_ekem_pk, nr, m) @ #x1
//               & #x1 < #t1
//               & not (Ex j_sig_pk_2 j_edh_pk_2 nr_2 s_dh_pk_2 #x2.
//                           Journalist_Received(j_sig_pk_2, j_edh_pk_2, nr_2, s_dh_pk_2, m) @ #x2
//                         & not (#x2 = #t1)))
//       | (Ex #x. Reveal_Source_DH_Key(s_dh_pk) @ #x)
//       | (Ex #x. Reveal_Journalist_SIG_Key(j_sig_pk) @ #x)
//       | (Ex #x. Reveal_Journalist_EDH_Key(j_edh_pk) @ #x)"

// not automatically verifiable
// lemma Executability_Journalist_Response:
// exists-trace
// "Ex #t1 #t2 s_dh_pk s_kem_pk j_sig_pk j_dh_pk nr m_old m.
//         Journalist_Response(j_sig_pk, j_dh_pk, nr, s_dh_pk, s_kem_pk, m_old, m) @ #t1
//       & Source_Received(s_dh_pk, j_dh_pk, nr, m) @ #t2
//       & (not Ex #x. AdversaryActivity() @ #x)"

// lemma Auto_Secrecy_Journalist_Message:
// "All #t1 #t2 #t3 s_dh_pk s_kem_pk j_sig_pk j_edh_pk j_ekem_pk j_dh_pk nr m_old m.
//         Source_Sent(s_dh_pk, j_sig_pk, j_edh_pk, j_ekem_pk, nr, m_old) @ #t1
//       & Journalist_Received(j_sig_pk, j_edh_pk, nr, s_dh_pk, m_old) @ #t2
//       & Journalist_Response(j_sig_pk, j_dh_pk, nr, s_dh_pk, s_kem_pk, m_old, m) @ #t3
//   ==>   (not Ex #x. K(m) @ #x)
//       | (  (Ex #x. Reveal_Source_KEM_Key(s_kem_pk) @ #x)
//          & (  (Ex #x. PQAttack() @ #x)
//             | (Ex #x. Reveal_Source_DH_Key(s_dh_pk) @ #x)))"

// lemma Auto_Non_Injective_Agreement_Journalist_Message:
// "All #t1 s_dh_pk j_dh_pk nr m.
//         Source_Received(s_dh_pk, j_dh_pk, nr, m) @ #t1
//   ==>   (Ex j_sig_pk s_kem_pk m_old #x.
//               Journalist_Response(j_sig_pk, j_dh_pk, nr, s_dh_pk, s_kem_pk, m_old, m) @ #x
//             & #x < #t1)
//       | (Ex #x. Reveal_Newsroom_Key(nr) @ #x)
//       | (Ex #x. Reveal_Journalist_DH_Key(j_dh_pk) @ #x)
//       | (Ex #x. Reveal_Source_DH_Key(s_dh_pk) @ #x)"

end
